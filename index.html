<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>üèπ Arrow Survival Maze - Escape or Die!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            min-height: 100dvh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            padding: 10px 0;
        }
        .game-container {
            text-align: center;
            padding: 5px;
            width: 100%;
            max-width: 550px;
        }

        h1 {
            color: #e94560;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
            font-size: clamp(1.2rem, 5vw, 2.2rem);
        }

        .info-panel {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 8px;
            color: #fff;
            font-size: clamp(0.7rem, 2.5vw, 1rem);
        }

        .info-box span {
            color: #00ff88;
            font-weight: bold;
        }

        .info-box.danger span {
            color: #e94560;
        }

        #gameCanvas {
            border: 3px solid #e94560;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.3);
            background: #0a0a1a;
            width: 100%;
            max-width: min(95vw, 500px);
            height: auto;
            aspect-ratio: 1;
            touch-action: none;
            display: block;
            margin: 0 auto;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 25px;
            font-size: 0.95rem;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        #startBtn {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #1a1a2e;
        }

        #startBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        #resetBtn {
            background: linear-gradient(135deg, #e94560, #c73659);
            color: white;
        }

        #resetBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }

        .arrow-keys {
            display: grid;
            grid-template-columns: repeat(3, clamp(50px, 15vw, 70px));
            grid-template-rows: repeat(2, clamp(50px, 15vw, 70px));
            gap: 8px;
            margin: 10px auto;
            width: fit-content;
        }

        .arrow-key {
            width: clamp(50px, 15vw, 70px);
            height: clamp(50px, 15vw, 70px);
            background: rgba(255, 255, 255, 0.15);
            border: 3px solid #00ff88;
            border-radius: 12px;
            color: #00ff88;
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.1s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .arrow-key:hover, .arrow-key:active {
            background: rgba(0, 255, 136, 0.5);
            transform: scale(0.9);
            border-color: #fff;
        }

        .arrow-key.empty {
            visibility: hidden;
        }

        .instructions {
            margin-top: 8px;
            color: #888;
            font-size: clamp(0.65rem, 2.5vw, 0.85rem);
            max-width: 95vw;
            margin-left: auto;
            margin-right: auto;
            padding: 0 10px;
        }

        .swipe-hint {
            display: none;
            color: #00ff88;
            font-size: clamp(0.8rem, 3vw, 1rem);
            margin-top: 5px;
            animation: pulse-text 1.5s infinite;
        }

        @keyframes pulse-text {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        @media (pointer: coarse) {
            .swipe-hint {
                display: block;
            }
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #aaa;
            font-size: clamp(0.6rem, 2vw, 0.8rem);
        }

        .legend-color {
            width: clamp(12px, 3vw, 18px);
            height: clamp(12px, 3vw, 18px);
            border-radius: 4px;
        }

        /* Mobile-specific styles */
        @media (max-width: 600px) {
            .game-container {
                padding: 5px;
            }
            
            h1 {
                margin-bottom: 5px;
            }
            
            .controls {
                margin-top: 8px;
                gap: 8px;
            }
            
            button {
                padding: 12px 20px;
                font-size: 0.9rem;
            }
        }

        @media (max-height: 700px) {
            .instructions {
                display: none;
            }
            
            .legend {
                display: none;
            }
        }

        .wall-color { background: #3a3a5c; }
        .player-color { background: #00ff88; }
        .arrow-color { background: #ff6b6b; }
        .exit-color { background: #ffd700; }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .game-over-box {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: clamp(20px, 5vw, 40px);
            border-radius: 20px;
            border: 3px solid #e94560;
            text-align: center;
            max-width: 90vw;
            margin: 20px;
        }

        .game-over-box h2 {
            color: #e94560;
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            margin-bottom: 15px;
        }

        .game-over-box.win h2 {
            color: #00ff88;
        }

        .game-over-box p {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        @keyframes levelUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 30px rgba(233, 69, 96, 0.3); }
            50% { box-shadow: 0 0 50px rgba(233, 69, 96, 0.6); }
        }

        #gameCanvas {
            animation: pulse 2s infinite;
        }

        .info-box.danger {
            animation: dangerPulse 1s infinite;
        }

        @keyframes dangerPulse {
            0%, 100% { background: rgba(255, 0, 0, 0.2); }
            50% { background: rgba(255, 0, 0, 0.4); }
        }

        .difficulty-selector {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .difficulty-selector span {
            color: #fff;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
        }

        .diff-btn {
            padding: 8px 15px;
            font-size: clamp(0.7rem, 2.5vw, 0.9rem);
            border: 2px solid #555;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .diff-btn:hover {
            border-color: #888;
            color: #fff;
        }

        .diff-btn.active {
            border-color: #00ff88;
            color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
        }

        #easyBtn.active { border-color: #00ff88; color: #00ff88; }
        #mediumBtn.active { border-color: #ffa500; color: #ffa500; background: rgba(255, 165, 0, 0.2); }
        #hardBtn.active { border-color: #ff4444; color: #ff4444; background: rgba(255, 68, 68, 0.2); }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üèπ SURVIVE & ESCAPE üíÄ</h1>
        
        <div class="info-panel">
            <div class="info-box">Level: <span id="level">1</span></div>
            <div class="info-box">Score: <span id="score">0</span></div>
            <div class="info-box">Escapes: <span id="escapes">0</span></div>
            <div class="info-box" id="difficultyDisplay">üòä <span id="diffText">Easy</span></div>
            <div class="info-box danger">‚ö†Ô∏è Arrows: <span id="arrowCount">0</span></div>
        </div>
        
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        
        <div class="arrow-keys">
            <div class="arrow-key empty"></div>
            <div class="arrow-key" id="upKey">‚Üë</div>
            <div class="arrow-key empty"></div>
            <div class="arrow-key" id="leftKey">‚Üê</div>
            <div class="arrow-key" id="downKey">‚Üì</div>
            <div class="arrow-key" id="rightKey">‚Üí</div>
        </div>
        
        <div class="controls">
            <button id="startBtn">‚ñ∂Ô∏è Start Game</button>
            <button id="resetBtn">üîÑ New Maze</button>
        </div>
        
        <div class="difficulty-selector">
            <span>Difficulty:</span>
            <button class="diff-btn active" id="easyBtn">üòä Easy</button>
            <button class="diff-btn" id="mediumBtn">üòê Medium</button>
            <button class="diff-btn" id="hardBtn">üíÄ Hard</button>
        </div>
        
        <p class="instructions">
            <strong>‚ö†Ô∏è SURVIVE:</strong> Arrows spawn INSIDE the maze and hunt you down!<br>
            <strong>üö™ ESCAPE:</strong> Find the ONLY exit before arrows get you!<br>
            <strong>üíÄ DANGER:</strong> The longer you stay, the more arrows spawn!<br>
            <strong>üéÆ CONTROLS:</strong> Arrow keys / WASD / Tap buttons / Swipe to move.
        </p>
        <p class="swipe-hint">üëÜ SWIPE on screen or TAP buttons to move!</p>
        
        <div class="legend">
            <div class="legend-item"><div class="legend-color wall-color"></div> Walls</div>
            <div class="legend-item"><div class="legend-color player-color"></div> You</div>
            <div class="legend-item"><div class="legend-color arrow-color"></div> Danger Arrow</div>
            <div class="legend-item"><div class="legend-color exit-color"></div> Exit</div>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-box" id="gameOverBox">
            <h2 id="gameOverTitle">Game Over!</h2>
            <p id="gameOverText">You were hit by an arrow!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="playAgainBtn">üîÑ Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const levelEl = document.getElementById('level');
        const scoreEl = document.getElementById('score');
        const escapesEl = document.getElementById('escapes');
        const arrowCountEl = document.getElementById('arrowCount');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverBox = document.getElementById('gameOverBox');
        const gameOverTitle = document.getElementById('gameOverTitle');
        const gameOverText = document.getElementById('gameOverText');
        const finalScoreEl = document.getElementById('finalScore');
        const playAgainBtn = document.getElementById('playAgainBtn');

        let CELL_SIZE = 25;
        const ROWS = 20;
        const COLS = 20;
        let canvasSize = 500;

        let maze = [];
        let player = { x: 10, y: 10 };
        let arrows = [];
        let exits = [];
        let gameRunning = false;
        let gameOver = false;
        let score = 0;
        let escapes = 0;
        let level = 1;
        let arrowInterval = null;
        let animationId = null;
        let arrowSpeed = 0.08;
        let arrowSpawnRate = 4000;
        let maxArrows = 2;
        let targetCell = null;
        let dangerLevel = 0;
        let survivalTime = 0;
        let survivalInterval = null;
        let exitPulse = 0;
        let warningCells = [];
        let difficulty = 'easy';

        // Difficulty settings
        const difficultySettings = {
            easy: {
                initialArrows: 1,
                maxArrows: 3,
                arrowSpeed: 0.06,
                spawnRate: 5000,
                spawnRateDecrease: 200,
                minSpawnRate: 2000,
                arrowsPerLevel: 0.5,
                warningTime: 1000,
                startDelay: 3000
            },
            medium: {
                initialArrows: 2,
                maxArrows: 6,
                arrowSpeed: 0.1,
                spawnRate: 3000,
                spawnRateDecrease: 250,
                minSpawnRate: 1200,
                arrowsPerLevel: 1,
                warningTime: 600,
                startDelay: 2000
            },
            hard: {
                initialArrows: 3,
                maxArrows: 10,
                arrowSpeed: 0.14,
                spawnRate: 2000,
                spawnRateDecrease: 300,
                minSpawnRate: 600,
                arrowsPerLevel: 1.5,
                warningTime: 400,
                startDelay: 1000
            }
        };

        // Load player image
        const playerImage = new Image();
        playerImage.src = 'Screenshot 2026-01-07 201947.png';
        let playerImageLoaded = false;

        // Responsive canvas sizing
        function resizeCanvas() {
            const containerWidth = Math.min(window.innerWidth * 0.95, 500);
            const containerHeight = Math.min(window.innerHeight * 0.5, 500);
            canvasSize = Math.floor(Math.min(containerWidth, containerHeight));
            
            // Make canvas size divisible by ROWS for clean cells
            canvasSize = Math.floor(canvasSize / ROWS) * ROWS;
            if (canvasSize < 200) canvasSize = 200;
            
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            CELL_SIZE = canvasSize / ROWS;
            
            // Redraw if game exists
            if (maze.length > 0) {
                drawGame();
            }
        }

        // Maze generation - Single Exit Version
        function generateMaze() {
            maze = [];
            for (let y = 0; y < ROWS; y++) {
                maze[y] = [];
                for (let x = 0; x < COLS; x++) {
                    maze[y][x] = 1;
                }
            }

            function carve(x, y) {
                maze[y][x] = 0;
                const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);

                for (let [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx > 0 && nx < COLS - 1 && ny > 0 && ny < ROWS - 1 && maze[ny][nx] === 1) {
                        maze[y + dy/2][x + dx/2] = 0;
                        carve(nx, ny);
                    }
                }
            }

            carve(1, 1);

            // Clear center area for player start
            const centerX = Math.floor(COLS / 2);
            const centerY = Math.floor(ROWS / 2);
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (centerY + dy > 0 && centerY + dy < ROWS - 1 &&
                        centerX + dx > 0 && centerX + dx < COLS - 1) {
                        maze[centerY + dy][centerX + dx] = 0;
                    }
                }
            }

            player = { x: centerX, y: centerY };

            // Create ONLY ONE exit - randomly on one edge, far from player
            exits = [];
            const side = Math.floor(Math.random() * 4);
            let ex, ey;
            
            switch(side) {
                case 0: // Top
                    ex = Math.random() < 0.5 ? 1 + Math.floor(Math.random() * 4) : COLS - 2 - Math.floor(Math.random() * 4);
                    ey = 0;
                    maze[0][ex] = 0;
                    maze[1][ex] = 0;
                    break;
                case 1: // Bottom
                    ex = Math.random() < 0.5 ? 1 + Math.floor(Math.random() * 4) : COLS - 2 - Math.floor(Math.random() * 4);
                    ey = ROWS - 1;
                    maze[ROWS-1][ex] = 0;
                    maze[ROWS-2][ex] = 0;
                    break;
                case 2: // Left
                    ey = Math.random() < 0.5 ? 1 + Math.floor(Math.random() * 4) : ROWS - 2 - Math.floor(Math.random() * 4);
                    ex = 0;
                    maze[ey][0] = 0;
                    maze[ey][1] = 0;
                    break;
                case 3: // Right
                    ey = Math.random() < 0.5 ? 1 + Math.floor(Math.random() * 4) : ROWS - 2 - Math.floor(Math.random() * 4);
                    ex = COLS - 1;
                    maze[ey][COLS-1] = 0;
                    maze[ey][COLS-2] = 0;
                    break;
            }
            
            exits.push({ x: ex, y: ey });

            // Create ONE clear path from center to exit
            let pathX = ex === 0 ? 1 : (ex === COLS - 1 ? COLS - 2 : ex);
            let pathY = ey === 0 ? 1 : (ey === ROWS - 1 ? ROWS - 2 : ey);

            while (Math.abs(pathX - centerX) > 1 || Math.abs(pathY - centerY) > 1) {
                maze[pathY][pathX] = 0;
                if (Math.random() < 0.6) {
                    if (pathX < centerX) pathX++;
                    else if (pathX > centerX) pathX--;
                } else {
                    if (pathY < centerY) pathY++;
                    else if (pathY > centerY) pathY--;
                }
            }

            // Add some extra paths for variety but keep it challenging
            for (let i = 0; i < 25; i++) {
                const rx = Math.floor(Math.random() * (COLS - 2)) + 1;
                const ry = Math.floor(Math.random() * (ROWS - 2)) + 1;
                maze[ry][rx] = 0;
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update exit pulse animation
            exitPulse += 0.1;

            // Draw maze with danger tint based on arrow count
            const dangerTint = Math.min(arrows.length * 15, 60);
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = `rgb(${58 + dangerTint}, ${58 - dangerTint/2}, ${92 - dangerTint})`;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        ctx.fillStyle = '#4a4a6c';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - 2, 2);
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, 2, CELL_SIZE - 2);
                    } else {
                        ctx.fillStyle = `rgb(${26 + dangerTint/2}, ${26 - dangerTint/4}, ${46 - dangerTint/2})`;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw warning cells (where arrows will spawn)
            warningCells.forEach(cell => {
                const alpha = 0.3 + Math.sin(Date.now() / 100) * 0.2;
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.fillRect(cell.x * CELL_SIZE, cell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(cell.x * CELL_SIZE + 2, cell.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            });

            // Draw target cell indicator (where player is moving to)
            if (targetCell && gameRunning) {
                ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
                ctx.fillRect(targetCell.x * CELL_SIZE, targetCell.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.strokeRect(targetCell.x * CELL_SIZE + 2, targetCell.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            }

            // Draw THE ONLY exit with intense pulsing glow
            exits.forEach(exit => {
                const pulseSize = Math.sin(exitPulse) * 5 + 10;
                const glowIntensity = Math.sin(exitPulse * 2) * 0.3 + 0.7;
                
                // Outer glow
                ctx.save();
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20 + pulseSize;
                
                const gradient = ctx.createRadialGradient(
                    exit.x * CELL_SIZE + CELL_SIZE / 2,
                    exit.y * CELL_SIZE + CELL_SIZE / 2,
                    0,
                    exit.x * CELL_SIZE + CELL_SIZE / 2,
                    exit.y * CELL_SIZE + CELL_SIZE / 2,
                    CELL_SIZE + pulseSize
                );
                gradient.addColorStop(0, `rgba(255, 215, 0, ${glowIntensity})`);
                gradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(exit.x * CELL_SIZE - pulseSize, exit.y * CELL_SIZE - pulseSize, 
                            CELL_SIZE + pulseSize * 2, CELL_SIZE + pulseSize * 2);
                ctx.restore();
                
                // Exit icon
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üö™', exit.x * CELL_SIZE + CELL_SIZE / 2, exit.y * CELL_SIZE + CELL_SIZE / 2);
                
                // "EXIT" text above
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 10px Arial';
                ctx.fillText('EXIT', exit.x * CELL_SIZE + CELL_SIZE / 2, exit.y * CELL_SIZE - 5);
            });

            // Draw arrows
            arrows.forEach(arrow => {
                drawArrow(arrow);
            });

            // Draw player
            ctx.save();
            if (playerImageLoaded) {
                // Draw the player image with glow
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 15 + Math.sin(Date.now() / 200) * 5;
                ctx.drawImage(
                    playerImage,
                    player.x * CELL_SIZE + 1,
                    player.y * CELL_SIZE + 1,
                    CELL_SIZE - 2,
                    CELL_SIZE - 2
                );
            } else {
                // Fallback to circle if image not loaded
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(
                    player.x * CELL_SIZE + CELL_SIZE / 2,
                    player.y * CELL_SIZE + CELL_SIZE / 2,
                    CELL_SIZE / 2 - 3,
                    0, Math.PI * 2
                );
                ctx.fillStyle = '#00ff88';
                ctx.fill();
            }
            ctx.restore();

            // Draw danger level indicator on screen
            if (gameRunning && arrows.length > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${0.3 + arrows.length * 0.1})`;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`‚ö†Ô∏è DANGER: ${arrows.length} arrows hunting you!`, 10, 20);
            }

            // Draw survival time
            if (gameRunning) {
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`‚è±Ô∏è ${survivalTime}s`, canvas.width - 10, 20);
            }
        }

        function drawArrow(arrow) {
            const x = arrow.x * CELL_SIZE + CELL_SIZE / 2 + arrow.offsetX;
            const y = arrow.y * CELL_SIZE + CELL_SIZE / 2 + arrow.offsetY;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(arrow.angle);

            // Pulsing glow effect
            const pulse = Math.sin(Date.now() / 100) * 5 + 15;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = pulse;

            // Arrow head - larger and more menacing
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-6, -8);
            ctx.lineTo(-2, 0);
            ctx.lineTo(-6, 8);
            ctx.closePath();
            ctx.fillStyle = '#ff3333';
            ctx.fill();
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Arrow shaft - thicker
            ctx.beginPath();
            ctx.moveTo(-2, 0);
            ctx.lineTo(-18, 0);
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Feathers - more prominent
            ctx.beginPath();
            ctx.moveTo(-14, 0);
            ctx.lineTo(-22, -6);
            ctx.moveTo(-14, 0);
            ctx.lineTo(-22, 6);
            ctx.moveTo(-16, 0);
            ctx.lineTo(-24, -4);
            ctx.moveTo(-16, 0);
            ctx.lineTo(-24, 4);
            ctx.strokeStyle = '#ff9900';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Trail effect
            ctx.beginPath();
            ctx.moveTo(-18, 0);
            ctx.lineTo(-35, 0);
            const trailGradient = ctx.createLinearGradient(-18, 0, -35, 0);
            trailGradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
            trailGradient.addColorStop(1, 'rgba(255, 100, 100, 0)');
            ctx.strokeStyle = trailGradient;
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.restore();
        }

        function spawnArrow() {
            if (!gameRunning || gameOver) return;
            if (arrows.length >= maxArrows) return;

            // Find valid spawn points INSIDE the maze (empty cells far from player)
            const validSpawns = [];
            for (let y = 1; y < ROWS - 1; y++) {
                for (let x = 1; x < COLS - 1; x++) {
                    if (maze[y][x] === 0) {
                        const distToPlayer = Math.abs(x - player.x) + Math.abs(y - player.y);
                        // Spawn at least 5 cells away from player
                        if (distToPlayer >= 5) {
                            validSpawns.push({ x, y, dist: distToPlayer });
                        }
                    }
                }
            }

            if (validSpawns.length === 0) return;

            // Pick a random spawn point
            const spawnPoint = validSpawns[Math.floor(Math.random() * validSpawns.length)];
            
            // Show warning before arrow spawns
            warningCells.push({ x: spawnPoint.x, y: spawnPoint.y, time: Date.now() });
            
            // Spawn arrow after warning delay
            setTimeout(() => {
                if (!gameRunning || gameOver) return;
                
                // Remove warning
                warningCells = warningCells.filter(c => c.x !== spawnPoint.x || c.y !== spawnPoint.y);
                
                // Find path from spawn to PLAYER (arrows hunt the player!)
                const path = findPath(spawnPoint.x, spawnPoint.y, player.x, player.y);
                
                if (path && path.length > 1) {
                    const dx = path[1].x - path[0].x;
                    const dy = path[1].y - path[0].y;
                    const angle = Math.atan2(dy, dx);

                    const arrow = {
                        x: spawnPoint.x,
                        y: spawnPoint.y,
                        targetX: player.x,
                        targetY: player.y,
                        path: path,
                        pathIndex: 0,
                        angle: angle,
                        offsetX: 0,
                        offsetY: 0,
                        progress: 0,
                        hunting: true
                    };

                    arrows.push(arrow);
                    arrowCountEl.textContent = arrows.length;
                }
            }, difficultySettings[difficulty].warningTime); // Warning time based on difficulty
        }

        function spawnMultipleArrows() {
            if (!gameRunning || gameOver) return;
            
            // Spawn arrows based on difficulty and level
            const settings = difficultySettings[difficulty];
            const baseArrows = difficulty === 'easy' ? 1 : (difficulty === 'medium' ? 1 : 2);
            const arrowsToSpawn = Math.min(baseArrows + Math.floor(level / 3), 3);
            
            for (let i = 0; i < arrowsToSpawn; i++) {
                setTimeout(() => spawnArrow(), i * 500);
            }
        }

        function findPath(startX, startY, targetX, targetY) {
            const queue = [[startX, startY, []]];
            const visited = new Set();
            visited.add(`${startX},${startY}`);

            while (queue.length > 0) {
                const [x, y, path] = queue.shift();

                if (x === targetX && y === targetY) {
                    return [...path, { x, y }];
                }

                const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]].sort(() => Math.random() - 0.5);
                
                for (let [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    const key = `${nx},${ny}`;

                    if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS &&
                        maze[ny][nx] === 0 && !visited.has(key)) {
                        visited.add(key);
                        queue.push([nx, ny, [...path, { x, y }]]);
                    }
                }
            }

            return null;
        }

        function updateArrows() {
            const settings = difficultySettings[difficulty];
            
            for (let i = arrows.length - 1; i >= 0; i--) {
                const arrow = arrows[i];
                
                arrow.progress += settings.arrowSpeed; // Arrow speed based on difficulty
                
                if (arrow.progress >= 1) {
                    arrow.progress = 0;
                    arrow.pathIndex++;
                    
                    // Arrow reached end of path
                    if (arrow.pathIndex >= arrow.path.length) {
                        // If arrow was hunting, try to recalculate path to player
                        if (arrow.hunting) {
                            const newPath = findPath(arrow.x, arrow.y, player.x, player.y);
                            if (newPath && newPath.length > 1) {
                                arrow.path = newPath;
                                arrow.pathIndex = 0;
                                const dx = arrow.path[1].x - arrow.path[0].x;
                                const dy = arrow.path[1].y - arrow.path[0].y;
                                arrow.angle = Math.atan2(dy, dx);
                                continue;
                            }
                        }
                        // Remove arrow if it can't continue
                        arrows.splice(i, 1);
                        arrowCountEl.textContent = arrows.length;
                        continue;
                    }
                    
                    arrow.x = arrow.path[arrow.pathIndex].x;
                    arrow.y = arrow.path[arrow.pathIndex].y;
                    
                    // Recalculate path to player every few steps (smart hunting)
                    if (arrow.hunting && arrow.pathIndex % 3 === 0) {
                        const newPath = findPath(arrow.x, arrow.y, player.x, player.y);
                        if (newPath && newPath.length > 1) {
                            arrow.path = newPath;
                            arrow.pathIndex = 0;
                        }
                    }
                    
                    if (arrow.pathIndex < arrow.path.length - 1) {
                        const dx = arrow.path[arrow.pathIndex + 1].x - arrow.x;
                        const dy = arrow.path[arrow.pathIndex + 1].y - arrow.y;
                        arrow.angle = Math.atan2(dy, dx);
                    }
                }
                
                // Smooth movement
                if (arrow.pathIndex < arrow.path.length - 1) {
                    const nextPos = arrow.path[arrow.pathIndex + 1];
                    arrow.offsetX = (nextPos.x - arrow.x) * CELL_SIZE * arrow.progress;
                    arrow.offsetY = (nextPos.y - arrow.y) * CELL_SIZE * arrow.progress;
                }

                // Check collision with player
                const arrowCenterX = arrow.x * CELL_SIZE + CELL_SIZE / 2 + arrow.offsetX;
                const arrowCenterY = arrow.y * CELL_SIZE + CELL_SIZE / 2 + arrow.offsetY;
                const playerCenterX = player.x * CELL_SIZE + CELL_SIZE / 2;
                const playerCenterY = player.y * CELL_SIZE + CELL_SIZE / 2;
                
                const dist = Math.sqrt(
                    Math.pow(arrowCenterX - playerCenterX, 2) +
                    Math.pow(arrowCenterY - playerCenterY, 2)
                );
                
                if (dist < CELL_SIZE * 0.6) {
                    endGame(false);
                    return;
                }
            }
        }

        function movePlayer(dx, dy) {
            if (!gameRunning || gameOver) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS && maze[newY][newX] === 0) {
                player.x = newX;
                player.y = newY;
                checkExit();
            }
        }

        function movePlayerToTarget() {
            if (!gameRunning || gameOver || !targetCell) return;
            
            // Find path from player to target
            const path = findPath(player.x, player.y, targetCell.x, targetCell.y);
            
            if (path && path.length > 1) {
                // Move one step towards target
                player.x = path[1].x;
                player.y = path[1].y;
                
                // Check if reached target
                if (player.x === targetCell.x && player.y === targetCell.y) {
                    targetCell = null;
                }
                
                checkExit();
            } else {
                targetCell = null;
            }
        }

        function checkExit() {
            // Check if reached THE ONLY exit
            const reachedExit = exits.some(exit => exit.x === player.x && exit.y === player.y);
            if (reachedExit) {
                escapes++;
                escapesEl.textContent = escapes;
                
                const settings = difficultySettings[difficulty];
                
                // Bonus points for survival time and difficulty
                const diffMultiplier = difficulty === 'easy' ? 1 : (difficulty === 'medium' ? 1.5 : 2);
                const timeBonus = survivalTime * 10 * diffMultiplier;
                const levelBonus = level * 100 * diffMultiplier;
                score += Math.floor(200 + timeBonus + levelBonus);
                scoreEl.textContent = score;
                level++;
                levelEl.textContent = level;

                // Reset survival time for new level
                survivalTime = 0;
                
                // Gradual difficulty increase per level
                arrowSpawnRate = Math.max(settings.minSpawnRate, arrowSpawnRate - settings.spawnRateDecrease);
                maxArrows = Math.min(settings.maxArrows, settings.initialArrows + Math.floor(level * settings.arrowsPerLevel));
                
                // Show level up message
                showLevelUp();

                // Start new level with new maze
                clearInterval(arrowInterval);
                arrows = [];
                warningCells = [];
                targetCell = null;
                arrowCountEl.textContent = 0;
                generateMaze();
                
                // Longer break between levels on easy mode
                const breakTime = difficulty === 'easy' ? 3000 : (difficulty === 'medium' ? 2000 : 1500);
                
                setTimeout(() => {
                    if (gameRunning) {
                        arrowInterval = setInterval(spawnMultipleArrows, arrowSpawnRate);
                        // Delay first arrow on new level
                        setTimeout(() => {
                            if (gameRunning) spawnArrow();
                        }, difficulty === 'easy' ? 2000 : 1000);
                    }
                }, breakTime);
            }
        }

        function showLevelUp() {
            const settings = difficultySettings[difficulty];
            const diffMultiplier = difficulty === 'easy' ? 1 : (difficulty === 'medium' ? 1.5 : 2);
            
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(0, 255, 136, 0.95), rgba(0, 200, 100, 0.95));
                color: #1a1a2e;
                padding: clamp(20px, 5vw, 40px) clamp(30px, 8vw, 80px);
                border-radius: 20px;
                font-size: clamp(1.5rem, 5vw, 2.5rem);
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                border: 4px solid #fff;
                box-shadow: 0 0 50px rgba(0, 255, 136, 0.8);
                animation: levelUp 2s ease-out forwards;
                max-width: 90vw;
            `;
            const timeBonus = Math.floor((survivalTime || 1) * 10 * diffMultiplier);
            const levelBonus = Math.floor((level - 1) * 100 * diffMultiplier);
            
            // Different messages based on difficulty
            const nextLevelMsg = difficulty === 'easy' ? 
                'Keep going! üåü' : 
                (difficulty === 'medium' ? 'Getting harder! ‚ö°' : 'DANGER INCOMING! üíÄ');
            
            overlay.innerHTML = `
                üéâ ESCAPED! üéâ<br>
                <span style="font-size: clamp(1.2rem, 4vw, 1.8rem);">LEVEL ${level}</span><br>
                <span style="font-size: clamp(0.7rem, 2.5vw, 1rem); color: #1a5a2e;">
                    +200 escape bonus<br>
                    +${timeBonus} time bonus<br>
                    +${levelBonus} level bonus<br>
                    <strong>${nextLevelMsg}</strong>
                </span>
            `;
            document.body.appendChild(overlay);
            
            const breakTime = difficulty === 'easy' ? 2500 : (difficulty === 'medium' ? 2000 : 1500);
            setTimeout(() => overlay.remove(), breakTime);
        }

        function gameLoop() {
            if (gameOver) return;
            
            updateArrows();
            
            // Auto-move player towards target cell
            if (targetCell && gameRunning) {
                movePlayerToTarget();
            }
            
            drawGame();
            
            if (gameRunning) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        function startGame() {
            if (gameRunning) return;
            
            const settings = difficultySettings[difficulty];
            
            // Apply difficulty settings
            arrowSpawnRate = settings.spawnRate;
            maxArrows = settings.initialArrows + Math.floor(level * settings.arrowsPerLevel);
            arrowSpeed = settings.arrowSpeed;
            
            gameRunning = true;
            gameOver = false;
            survivalTime = 0;
            warningCells = [];
            startBtn.textContent = 'üíÄ SURVIVE!';
            startBtn.disabled = true;
            
            // Disable difficulty buttons during game
            document.querySelectorAll('.diff-btn').forEach(btn => btn.disabled = true);
            
            // Start survival timer
            survivalInterval = setInterval(() => {
                if (gameRunning && !gameOver) {
                    survivalTime++;
                    // Gradual difficulty increase over time (slower on easy)
                    const increaseRate = difficulty === 'easy' ? 20 : (difficulty === 'medium' ? 15 : 10);
                    if (survivalTime % increaseRate === 0) {
                        maxArrows = Math.min(maxArrows + 1, settings.maxArrows);
                        arrowSpawnRate = Math.max(arrowSpawnRate - settings.spawnRateDecrease, settings.minSpawnRate);
                    }
                }
            }, 1000);
            
            // Spawn initial arrows after delay based on difficulty
            setTimeout(() => {
                if (gameRunning) spawnArrow();
            }, settings.startDelay);
            
            arrowInterval = setInterval(spawnMultipleArrows, arrowSpawnRate);
            gameLoop();
        }

        function endGame(won) {
            gameRunning = false;
            gameOver = true;
            clearInterval(arrowInterval);
            clearInterval(survivalInterval);
            cancelAnimationFrame(animationId);
            
            gameOverBox.className = won ? 'game-over-box win' : 'game-over-box';
            gameOverTitle.textContent = won ? 'üéâ YOU ESCAPED!' : 'üíÄ YOU DIED!';
            gameOverText.textContent = won ? 
                `Amazing! You survived ${survivalTime}s and escaped ${escapes} times!` : 
                `You survived ${survivalTime} seconds before being hit!`;
            finalScoreEl.textContent = score;
            gameOverOverlay.style.display = 'flex';
        }

        function resetGame() {
            gameRunning = false;
            gameOver = false;
            clearInterval(arrowInterval);
            clearInterval(survivalInterval);
            cancelAnimationFrame(animationId);
            
            const settings = difficultySettings[difficulty];
            
            arrows = [];
            score = 0;
            escapes = 0;
            level = 1;
            survivalTime = 0;
            arrowSpawnRate = settings.spawnRate;
            maxArrows = settings.initialArrows;
            arrowSpeed = settings.arrowSpeed;
            targetCell = null;
            warningCells = [];
            
            levelEl.textContent = level;
            scoreEl.textContent = score;
            escapesEl.textContent = escapes;
            arrowCountEl.textContent = 0;
            
            startBtn.textContent = '‚ñ∂Ô∏è Start Game';
            startBtn.disabled = false;
            gameOverOverlay.style.display = 'none';
            
            // Re-enable difficulty buttons
            document.querySelectorAll('.diff-btn').forEach(btn => btn.disabled = false);
            
            generateMaze();
            drawGame();
        }

        // Event listeners
        startBtn.addEventListener('click', startGame);
        resetBtn.addEventListener('click', resetGame);
        playAgainBtn.addEventListener('click', resetGame);

        // Difficulty selection
        const diffTextEl = document.getElementById('diffText');
        const diffDisplayEl = document.getElementById('difficultyDisplay');
        
        function setDifficulty(diff) {
            difficulty = diff;
            
            // Update button states
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(diff + 'Btn').classList.add('active');
            
            // Update display
            const icons = { easy: 'üòä', medium: 'üòê', hard: 'üíÄ' };
            const colors = { easy: '#00ff88', medium: '#ffa500', hard: '#ff4444' };
            diffTextEl.textContent = diff.charAt(0).toUpperCase() + diff.slice(1);
            diffDisplayEl.innerHTML = `${icons[diff]} <span id="diffText" style="color: ${colors[diff]}">${diffTextEl.textContent}</span>`;
            
            // Reset game with new difficulty
            if (!gameRunning) {
                resetGame();
            }
        }
        
        document.getElementById('easyBtn').addEventListener('click', () => setDifficulty('easy'));
        document.getElementById('mediumBtn').addEventListener('click', () => setDifficulty('medium'));
        document.getElementById('hardBtn').addEventListener('click', () => setDifficulty('hard'));

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    movePlayer(0, -1);
                    e.preventDefault();
                    break;
                case 'ArrowDown': case 's': case 'S':
                    movePlayer(0, 1);
                    e.preventDefault();
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    movePlayer(-1, 0);
                    e.preventDefault();
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    movePlayer(1, 0);
                    e.preventDefault();
                    break;
            }
        });

        // Touch/click controls for buttons
        document.getElementById('upKey').addEventListener('click', () => movePlayer(0, -1));
        document.getElementById('downKey').addEventListener('click', () => movePlayer(0, 1));
        document.getElementById('leftKey').addEventListener('click', () => movePlayer(-1, 0));
        document.getElementById('rightKey').addEventListener('click', () => movePlayer(1, 0));

        // Touch controls for buttons - prevent double firing
        document.getElementById('upKey').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(0, -1); });
        document.getElementById('downKey').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(0, 1); });
        document.getElementById('leftKey').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(-1, 0); });
        document.getElementById('rightKey').addEventListener('touchstart', (e) => { e.preventDefault(); movePlayer(1, 0); });

        // Swipe controls for the entire screen
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 30;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            // Ignore if touching buttons
            if (e.target.classList.contains('arrow-key') || e.target.tagName === 'BUTTON') {
                return;
            }
            
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, { passive: true });

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);

            if (Math.max(absDeltaX, absDeltaY) < minSwipeDistance) {
                return; // Too small to be a swipe
            }

            if (absDeltaX > absDeltaY) {
                // Horizontal swipe
                if (deltaX > 0) {
                    movePlayer(1, 0); // Right
                } else {
                    movePlayer(-1, 0); // Left
                }
            } else {
                // Vertical swipe
                if (deltaY > 0) {
                    movePlayer(0, 1); // Down
                } else {
                    movePlayer(0, -1); // Up
                }
            }
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            resizeCanvas();
        });
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        // Prevent default touch behaviors on canvas
        canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });

        // Initialize
        playerImage.onload = () => {
            playerImageLoaded = true;
            drawGame();
        };
        
        resizeCanvas();
        generateMaze();
        drawGame();
    </script>
</body>
</html>